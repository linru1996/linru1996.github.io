<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.1">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Consolas, Monda:300,300italic,400,400italic,700,700italic|Consolas, Roboto Slab:300,300italic,400,400italic,700,700italic|Consolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="一、SQL语句执行 基本架构MVCC—-多版本并发控制当前读和一致性读慢查询日志 slow log—可以查到扫描行数 Server层+存储引擎层Server层：连接器、查询缓存、分析器、优化器、执行器等  以及内置函数，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。存储引擎层：数据的存储和提取，架构模式是插件式的。支持InnoDB、MyISAM、Memory等多个存储引擎。">
<meta name="keywords" content="study">
<meta property="og:type" content="article">
<meta property="og:title" content="Mysql学习-1（架构、日志、事务、索引）">
<meta property="og:url" content="http://yoursite.com/2019/12/24/Mysql学习-1（架构、日志、事务、索引）/index.html">
<meta property="og:site_name" content="ALWAYS">
<meta property="og:description" content="一、SQL语句执行 基本架构MVCC—-多版本并发控制当前读和一致性读慢查询日志 slow log—可以查到扫描行数 Server层+存储引擎层Server层：连接器、查询缓存、分析器、优化器、执行器等  以及内置函数，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。存储引擎层：数据的存储和提取，架构模式是插件式的。支持InnoDB、MyISAM、Memory等多个存储引擎。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-12-26T12:14:33.046Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mysql学习-1（架构、日志、事务、索引）">
<meta name="twitter:description" content="一、SQL语句执行 基本架构MVCC—-多版本并发控制当前读和一致性读慢查询日志 slow log—可以查到扫描行数 Server层+存储引擎层Server层：连接器、查询缓存、分析器、优化器、执行器等  以及内置函数，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。存储引擎层：数据的存储和提取，架构模式是插件式的。支持InnoDB、MyISAM、Memory等多个存储引擎。">
  <link rel="canonical" href="http://yoursite.com/2019/12/24/Mysql学习-1（架构、日志、事务、索引）/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Mysql学习-1（架构、日志、事务、索引） | ALWAYS</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ALWAYS</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
        
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      
    
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">
          <i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/24/Mysql学习-1（架构、日志、事务、索引）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ALWAYS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            Mysql学习-1（架构、日志、事务、索引）
            

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-12-24 21:37:38" itemprop="dateCreated datePublished" datetime="2019-12-24T21:37:38+08:00">2019-12-24</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-12-26 20:14:33" itemprop="dateModified" datetime="2019-12-26T20:14:33+08:00">2019-12-26</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mysql/" itemprop="url" rel="index">
                    <span itemprop="name">Mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="一、SQL语句执行-基本架构"><a href="#一、SQL语句执行-基本架构" class="headerlink" title="一、SQL语句执行 基本架构"></a>一、SQL语句执行 基本架构</h1><h3 id="MVCC—-多版本并发控制"><a href="#MVCC—-多版本并发控制" class="headerlink" title="MVCC—-多版本并发控制"></a>MVCC—-多版本并发控制</h3><h3 id="当前读和一致性读"><a href="#当前读和一致性读" class="headerlink" title="当前读和一致性读"></a>当前读和一致性读</h3><p>慢查询日志 slow log—可以查到扫描行数</p>
<p><span style="color:red;">Server层+存储引擎层</span><br><span style="color:red;">Server层：连接器、查询缓存、分析器、优化器、执行器等  以及内置函数，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</span><br>存储引擎层：数据的存储和提取，架构模式是插件式的。支持InnoDB、MyISAM、Memory等多个存储引擎。  engine=memory<br>不同的存储引擎共用一个Server层   </p>
<p>连接器：负责和客户端建立连接、获取权限、维持和管理连接<br>长连接可能导致内存占用过大  </p>
<p>查询缓存：mysql拿到查询请求后会先查看查询缓存，如果语句不在查询缓存中会继续后面的执行阶段，执行结果会存入查询缓存中。<br>建议不要使用查询缓存，mysql8.0开始没有查询缓存功能。 在一个表上有更新的时候，跟这个表有关的查询缓存会失效。   </p>
<p>分析器：词法分析+语法分析  </p>
<p>优化器：在表里有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联的时候，决定各表的连接顺序。  </p>
<p>执行器：开始执行的时候，要先判断一下对这个表有没有执行查询的权限，如果有，继续执行。使用引擎提供的接口。   </p>
<h1 id="二、日志"><a href="#二、日志" class="headerlink" title="二、日志"></a>二、日志</h1><h2 id="WAL-技术"><a href="#WAL-技术" class="headerlink" title="WAL 技术"></a>WAL 技术</h2><p>WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。  </p>
<p>日志模块：redo log（重做日志）和binlog（归档日志）先写日志，再写磁盘。<br>语句更新会生成undo log（回滚日志）   </p>
<h2 id="redo-log（crash-safe能力）InnoDB特有"><a href="#redo-log（crash-safe能力）InnoDB特有" class="headerlink" title="redo log（crash-safe能力）InnoDB特有"></a>redo log（crash-safe能力）InnoDB特有</h2><p>当有一条记录需要更新的时候，InnoDB引擎会先把记录写到redo log中，并更新缓存，会在适当时候更新磁盘。<br>InnoDB的redo log大小固定，从头写到末尾。write pos当前记录位置，checkpoint当前擦出位置。往后推移并循环，擦除记录前要把记录更新到数据文件。  </p>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>Server层日志，没有crash-safe能力。binlog 没有能力恢复“数据页”    </p>
<h2 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h2><p>redo log是InnoDB特有，binlog在Mysql的server层实现，所有引擎都可以使用；<br>redo log是物理日志，记录的是“在摸个数据页上做了什么修改”，binlog是逻辑日志，记录的是语句的原始逻辑，比如“给ID=2这一行的c字段加一”；<br>redo log循环写，空间固定会用完；binlog是可以追加写入，写到一定大小会切换到下一个，不会覆盖。  </p>
<h2 id="执行update流程："><a href="#执行update流程：" class="headerlink" title="执行update流程："></a>执行update流程：</h2><ol>
<li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。  </li>
<li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。  </li>
<li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。  </li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。  </li>
</ol>
<p>redo log拆成prepare和commit，<span style="color:red;">两阶段提交</span>，保证日志恢复出来的库的状态和原库一致。   </p>
<h2 id="两阶段提交时Mysql异常重启后事务情况："><a href="#两阶段提交时Mysql异常重启后事务情况：" class="headerlink" title="两阶段提交时Mysql异常重启后事务情况："></a>两阶段提交时Mysql异常重启后事务情况：</h2><h3 id="崩溃恢复时的判断规则："><a href="#崩溃恢复时的判断规则：" class="headerlink" title="崩溃恢复时的判断规则："></a>崩溃恢复时的判断规则：</h3><pre><code>1. 如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交；
2. 如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整：（一个事务的 binlog 是有完整格式的）
    a. 如果是，则提交事务；
    b. 否则，回滚事务。  </code></pre><p>对于 InnoDB 引擎来说，如果 redo log 提交完成了，事务就不能回滚（如果这还允许回滚，就可能覆盖掉别的事务的更新）。而如果 redo log 直接提交，然后 binlog 写入的时候失败，InnoDB 又回滚不了，数据和 binlog 日志又不一致了。  </p>
<p>让数据库恢复到半个月内任意一秒的状态：找到全量备份，从备份的时间点开始取出binlog  </p>
<p>redo log 用于保证 <span style="color:red;">crash-safe</span> 能力。innodb_flush_log_at_trx_commit 这个参数设置成1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数建议设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。<br>sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数也建议设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。    </p>
<h3 id="binlog-有着-redo-log-无法替代的功能。"><a href="#binlog-有着-redo-log-无法替代的功能。" class="headerlink" title="binlog 有着 redo log 无法替代的功能。"></a>binlog 有着 redo log 无法替代的功能。</h3><pre><code>一个是归档。redo log 是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留，redo log 也就起不到归档的作用。
一个就是 MySQL 系统依赖于 binlog。binlog 作为 MySQL 一开始就有的功能，被用在了很多地方。其中，MySQL 系统高可用的基础，就是 binlog 复制。
还有很多公司有异构系统（比如一些数据分析系统），这些系统就靠消费 MySQL 的binlog 来更新自己的数据。关掉 binlog 的话，这些下游系统就没法输入了。   </code></pre><h3 id="正常运行中的实例，数据写入后的最终落盘，是从-redo-log-更新过来的还是从-buffer-pool-更新过来的？"><a href="#正常运行中的实例，数据写入后的最终落盘，是从-redo-log-更新过来的还是从-buffer-pool-更新过来的？" class="headerlink" title="正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的？"></a>正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的？</h3><p>实际上，redo log 并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据<br>页，也就不存在“数据最终落盘，是由 redo log 更新过去”的情况。</p>
<ol>
<li>如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与 redo log 毫无关系。  </li>
<li>在崩溃恢复场景中，InnoDB 如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让 redo log 更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。  </li>
</ol>
<h1 id="三、事务隔离"><a href="#三、事务隔离" class="headerlink" title="三、事务隔离"></a>三、事务隔离</h1><h2 id="可重复读是InnoDB默认的隔离级别"><a href="#可重复读是InnoDB默认的隔离级别" class="headerlink" title="可重复读是InnoDB默认的隔离级别"></a><span style="color:red;">可重复读是InnoDB默认的隔离级别</span></h2><h3 id="ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）"><a href="#ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）" class="headerlink" title="ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）"></a>ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</h3><h3 id="脏读（dirty-read）、不可重复读（non-repeatable-read）、幻读（phantom-read）"><a href="#脏读（dirty-read）、不可重复读（non-repeatable-read）、幻读（phantom-read）" class="headerlink" title="脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）"></a>脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）</h3><h2 id="SQL标准的事务隔离级别："><a href="#SQL标准的事务隔离级别：" class="headerlink" title="SQL标准的事务隔离级别："></a>SQL标准的事务隔离级别：</h2><p>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。<br>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。<br>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。<br>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当<br>出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。  </p>
<p>视图概念<br>将启动参数 transaction-isolation 的值设置成 READ-COMMITTED   </p>
<h2 id="Mysql的事务启动方式："><a href="#Mysql的事务启动方式：" class="headerlink" title="Mysql的事务启动方式："></a>Mysql的事务启动方式：</h2><ol>
<li>显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。   </li>
<li>set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。<br>有些客户端连接框架会默认连接成功后先执行一个 set autocommit=0 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。<br>建议总是使用 set autocommit=1, 通过显式语句的方式来启动事务。  ？？？？？？？存疑<br>在 autocommit 为 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。   </li>
</ol>
<h1 id="四、索引"><a href="#四、索引" class="headerlink" title="四、索引"></a>四、索引</h1><p>提高数据的查询效率  </p>
<h2 id="常见模型：哈希表、有序数组和搜索树。"><a href="#常见模型：哈希表、有序数组和搜索树。" class="headerlink" title="常见模型：哈希表、有序数组和搜索树。"></a>常见模型：哈希表、有序数组和搜索树。</h2><p>哈希表适用于只有等值查询的场景；<br>有序数组在等值查询和范围查询场景性能都可以，但只适应于静态存储引擎；<br>平衡二叉树：搜索时间复杂度O(log(n)),更新的时间复杂度 O(log(n))   </p>
<h3 id="InnoDB使用B-树模型，减少单次查询的磁盘访问次数。"><a href="#InnoDB使用B-树模型，减少单次查询的磁盘访问次数。" class="headerlink" title="InnoDB使用B+树模型，减少单次查询的磁盘访问次数。"></a>InnoDB使用B+树模型，减少单次查询的磁盘访问次数。</h3><p>主键索引和非主键索引<br><span style="color:red;"><br>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。<br>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。<br></span>    </p>
<h3 id="索引维护："><a href="#索引维护：" class="headerlink" title="索引维护："></a>索引维护：</h3><p>新插入数据记录。索引需要移动甚至会页分裂，页合并<br>自增主键：<br>覆盖索引：查询不需要回表，减少树的搜索次数，性能优化手段。<br>前缀索引：</p>
<h3 id="联合索引：安排索引内的字段顺序"><a href="#联合索引：安排索引内的字段顺序" class="headerlink" title="联合索引：安排索引内的字段顺序"></a>联合索引：安排索引内的字段顺序</h3><p>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。<br>索引下推优化    </p>
<h1 id="五、全局锁、表锁、行锁"><a href="#五、全局锁、表锁、行锁" class="headerlink" title="五、全局锁、表锁、行锁"></a>五、全局锁、表锁、行锁</h1><h2 id="1、全局锁"><a href="#1、全局锁" class="headerlink" title="1、全局锁"></a>1、全局锁</h2><p>全局锁的典型使用场景是，做全库逻辑备份。<br>全局锁主要用在逻辑备份过程中。对于全部是 InnoDB 引擎的库，建议选择使用–<br>single-transaction 参数，对应用会更友好。   </p>
<h2 id="2、表级锁"><a href="#2、表级锁" class="headerlink" title="2、表级锁"></a>2、表级锁</h2><p>表级锁：表锁、元数据锁（MDL）  </p>
<h3 id="1）表锁"><a href="#1）表锁" class="headerlink" title="1）表锁"></a>1）表锁</h3><p>表锁的语法：lock tables…read/write<br>表锁一般是在数据库引擎不支持行锁的时候才会被用到的。如果你发现你的应用程序里有lock tables 这样的语句，你需要追查一下，比较可能的情况是：<br>要么是你的系统现在还在用 MyISAM 这类不支持事务的引擎，那要安排升级换引擎；<br>要么是你的引擎升级了，但是代码还没升级。这样的情况，最后业务开发就是把<br>lock tables 和 unlock tables 改成 begin 和 commit，问题就解决了。   </p>
<h3 id="2）元数据锁"><a href="#2）元数据锁" class="headerlink" title="2）元数据锁"></a>2）元数据锁</h3><p>MDL 不需要显式只用，在访问一个表的时候会被自动加上，保证读写的正确性。<br>因此，在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁。<br>MDL会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。   </p>
<h2 id="3、行锁"><a href="#3、行锁" class="headerlink" title="3、行锁"></a>3、行锁</h2><h3 id="引擎层由各个引擎自己实现，不是所有引擎都支持。InnoDB支持。"><a href="#引擎层由各个引擎自己实现，不是所有引擎都支持。InnoDB支持。" class="headerlink" title="引擎层由各个引擎自己实现，不是所有引擎都支持。InnoDB支持。"></a>引擎层由各个引擎自己实现，不是所有引擎都支持。InnoDB支持。</h3><p><span style="color:red;">在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。 </span>     </p>
<p>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。<br>但是，调整语句顺序并不能完全避免死锁。引入了死锁和死锁检测的概念，以及提供了三个方案，来减少死锁对数据库的影响。减少死锁的主要方向，就是控制访问相同资源的并发事务量。    </p>
<h3 id="死锁：事务A等待事务B释放行锁，事务B等待事务A释放行锁。"><a href="#死锁：事务A等待事务B释放行锁，事务B等待事务A释放行锁。" class="headerlink" title="死锁：事务A等待事务B释放行锁，事务B等待事务A释放行锁。"></a>死锁：事务A等待事务B释放行锁，事务B等待事务A释放行锁。</h3><h3 id="解决策略："><a href="#解决策略：" class="headerlink" title="解决策略："></a>解决策略：</h3><ul>
<li>直接进入等待，直至超时。这个超时时间可以通过参数innodb_lock_wait_timeout 来设置。 InnoDB默认50s，过于长；    </li>
<li>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。InnoDB默认值为0。  <h3 id="但死锁检测存在问题：并发量大导致CPU资源耗费。"><a href="#但死锁检测存在问题：并发量大导致CPU资源耗费。" class="headerlink" title="但死锁检测存在问题：并发量大导致CPU资源耗费。"></a>但死锁检测存在问题：并发量大导致CPU资源耗费。</h3><h3 id="解决由这种热点行更新导致的性能问题："><a href="#解决由这种热点行更新导致的性能问题：" class="headerlink" title="解决由这种热点行更新导致的性能问题："></a>解决由这种热点行更新导致的性能问题：</h3>一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉；另一个思路是控制并发度，并发控制做在数据库服务端，可以考虑在中间件实现，或在Mysql里面，基本思路是，对于相同行的更新，在进入引擎之前排队。<br>或者，可以考虑通过将一行改成逻辑上的多行来减少锁冲突。  </li>
</ul>
<h1 id="六、事务隔离"><a href="#六、事务隔离" class="headerlink" title="六、事务隔离"></a>六、事务隔离</h1><p>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：   </p>
<ol>
<li>版本未提交，不可见；  </li>
<li>版本已提交，但是是在视图创建后提交的，不可见；  </li>
<li>版本已提交，而且是在视图创建前提交的，可见。  </li>
</ol>
<p>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。  </p>
<p>InnoDB 的行数据有多个版本，每个数据版本有自己的 row trx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性。<br>对于可重复读，查询只承认在事务启动前就已经提交完成的数据；<br>对于读提交，查询只承认在语句启动前就已经提交完成的数据；<br>而当前读，总是读取已经提交完成的最新版本。   </p>
<h1 id="七、普通索引和唯一索引"><a href="#七、普通索引和唯一索引" class="headerlink" title="七、普通索引和唯一索引"></a>七、普通索引和唯一索引</h1><p>这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。<br>由于唯一索引用不上 change buffer 的优化机制，因此如果业务可以接受，从性能角度出发建议优先考虑非唯一索引。 </p>
<h3 id="1-change-buffer："><a href="#1-change-buffer：" class="headerlink" title="1.change buffer："></a>1.change buffer：</h3><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 changebuffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。change buffer会持久化到磁盘。  </p>
<p><span style="color:red;">唯一索引需要首先保证唯一性，因此必须将数据读到内存查看，所以唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。</span>      </p>
<h3 id="2-merge："><a href="#2-merge：" class="headerlink" title="2.merge："></a>2.merge：</h3><p>将 change buffer 中的操作应用到原数据页。。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭<br>（shutdown）的过程中，也会执行 merge 操作。  </p>
<h3 id="3-change-buffer-的使用场景"><a href="#3-change-buffer-的使用场景" class="headerlink" title="3.change buffer 的使用场景"></a>3.change buffer 的使用场景</h3><p>change buffer 只限于用在普通索引的场景下，而不适用于唯一索引。那么，现在有一个问题就是：普通索引的所有场景，使用 change buffer 都可以起到加速作用吗？  </p>
<p>因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。  </p>
<p>因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时<br>change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。  </p>
<p>反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。    </p>
<p>如果所有的更新后面，都马上伴随着对这个记录的查询，那么应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能。  </p>
<p>在实际使用中，你会发现，普通索引和 change buffer 的配合使用，对于数据量大的表的更新优化还是很明显的。  </p>
<h3 id="4-change-buffer-和-redo-log"><a href="#4-change-buffer-和-redo-log" class="headerlink" title="4.change buffer 和 redo log"></a>4.change buffer 和 redo log</h3><p>简单地对比这两个机制在提升更新性能上的收益的话，redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘<br>的 IO 消耗。</p>
<pre><code>1. Page 1 在内存中，直接更新内存；
2. Page 2 没有在内存中，就在内存的 change buffer 区域，记录下“我要往 Page 2 插入一行”这个信息。
3. 将上述两个动作记入 redo log 中。</code></pre><h1 id="八、MySQL选择索引"><a href="#八、MySQL选择索引" class="headerlink" title="八、MySQL选择索引"></a>八、MySQL选择索引</h1><p>优化器存在选错索引的可能性   </p>
<p>而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。当然，扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。  </p>
<p>对于由于索引统计信息不准确导致的问题，可以用 analyze table t（重新统计索引信息） 来解决。<br>而对于其他优化器误判的情况，你可以在应用端用 force index 来强行指定索引，也可以通过修改语句来引导优化器，还可以通过增加或者删除索引来绕过这个问题。   </p>
<h2 id="索引选择异常和处理"><a href="#索引选择异常和处理" class="headerlink" title="索引选择异常和处理"></a>索引选择异常和处理</h2><pre><code>1.采用 force index 强行选择一个索引。  
2.可以考虑修改语句，引导 MySQL 使用期望的索引。  
3.在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。  </code></pre><h1 id="九、字符串字段加索引"><a href="#九、字符串字段加索引" class="headerlink" title="九、字符串字段加索引"></a>九、字符串字段加索引</h1><h2 id="1-前缀索引"><a href="#1-前缀索引" class="headerlink" title="1.前缀索引"></a>1.前缀索引</h2><p>MySQL 是支持前缀索引的，也就是说，你可以定义字符串的一部分作为索引。 使用前缀索引后，可能会导致查询语句读数据的次数变多。<br>alter table SUser add index index2(email(6));   </p>
<p><span style="color:red;">使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</span><br>select count(distinct email) as L from SUser;查看此列有多少个不同的值  </p>
<h2 id="2-前缀索引对覆盖索引的影响"><a href="#2-前缀索引对覆盖索引的影响" class="headerlink" title="2.前缀索引对覆盖索引的影响"></a>2.前缀索引对覆盖索引的影响</h2><p>使用前缀索引就用不上覆盖索引对查询性能的优化了  </p>
<h2 id="3-倒序存储和Hash字段索引："><a href="#3-倒序存储和Hash字段索引：" class="headerlink" title="3.倒序存储和Hash字段索引："></a>3.倒序存储和Hash字段索引：</h2><p>使用倒序存储：身份证索引<br>使用 hash 字段   </p>
<h3 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h3><pre><code>都不支持范围查询，只支持等值查询；   </code></pre><h3 id="区别：-1"><a href="#区别：-1" class="headerlink" title="区别："></a>区别：</h3><pre><code>1. 从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而hash 字段方法需要增加一个字段。当然，倒序存储方式使用 4 个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个 hash 字段也差不多抵消了。   

2. 在 CPU 消耗方面，倒序方式每次写和读的时候，都需要额外调用一次 reverse 函数，而 hash 字段的方式需要额外调用一次 crc32() 函数。如果只从这两个函数的计算复杂度来看的话，reverse 函数额外消耗的 CPU 资源会更小些。   

3. 从查询效率上看，使用 hash 字段方式的查询性能相对更稳定一些。因为 crc32 算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近 1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</code></pre><p>总结：<br>    1. 直接创建完整索引，这样可能比较占用空间；<br>    2. 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；<br>    3. 倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；<br>    4. 创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。   </p>
<h1 id="十、SQL语句偶尔变慢的原因"><a href="#十、SQL语句偶尔变慢的原因" class="headerlink" title="十、SQL语句偶尔变慢的原因"></a>十、SQL语句偶尔变慢的原因</h1><p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据<br>写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。   </p>
<p>MySQL 偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。  </p>
<p>flush场景：  </p>
<pre><code>- InnoDB 的 redo log 写满了。这时候系统会停止所有更新操作，把 checkpoint 往前推进，redo log 留出空间可以继续写。（nnoDB 要尽量避免）   
- 系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。
- MySQL 认为系统“空闲”的时候。
- MySQL 正常关闭的情况。   </code></pre><p>刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：  </p>
<pre><code>1. 一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；
2. 日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的。</code></pre><p>所以，InnoDB 需要有控制脏页比例的机制，来尽量避免上面的这两种情况。  </p>
<h2 id="InnoDB-刷脏页的控制策略"><a href="#InnoDB-刷脏页的控制策略" class="headerlink" title="InnoDB 刷脏页的控制策略"></a>InnoDB 刷脏页的控制策略</h2><p>正确地告诉 InnoDB 所在主机的 IO 能力，这样 InnoDB 才能知道需要全力刷脏页的时候，可以刷多快。innodb_io_capacity 这个参数，它会告诉 InnoDB 你的磁盘能力。这个值建议设置成磁盘的 IOPS。  </p>
<h2 id="设计策略控制刷脏页的速度，会参考因素："><a href="#设计策略控制刷脏页的速度，会参考因素：" class="headerlink" title="设计策略控制刷脏页的速度，会参考因素："></a>设计策略控制刷脏页的速度，会参考因素：</h2><p>一个是脏页比例，一个是 redo log 写盘速度。<br>参数 innodb_max_dirty_pages_pct 是脏页比例上限，默认值是 75%。<br>合理地设置 innodb_io_capacity 的值，并且平时要多关注脏页比例，不要让它经常接近 75%。    </p>
<h3 id="找“邻居”"><a href="#找“邻居”" class="headerlink" title="找“邻居”"></a>找“邻居”</h3><p>而 MySQL 中的一个机制，可能让你的查询会更慢：在准备刷一个脏页的时候，如果<br>这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个<br>把“邻居”拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。<br>在 InnoDB 中，innodb_flush_neighbors 参数就是用来控制这个行为的，值为 1 的时候会有上述的“连坐”机制，值为 0 时表示不找邻居，自己刷自己的。  </p>
<h1 id="十一、数据库表的空间回收"><a href="#十一、数据库表的空间回收" class="headerlink" title="十一、数据库表的空间回收"></a>十一、数据库表的空间回收</h1><p>表删掉一半，但表文件大小还是没变<br>InnoDB表包含：表结构定义和数据<br>表数据既可以存在共享表空间里，也可以是单独的文件。由参数innodb_file_per_table 控制，建议设置为单独的文件，便于管理和删除。   </p>
<h2 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h2><p>数据删除只是删除记录，重新插入的时候可以直接复用这个空间；<br>删除数据页的所有记录，则整个数据页就可以被复用了。当整个页从 B+ 树里面摘掉以后，可以复用到任何位置。 如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。    </p>
<p><span style="color:red;">delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，通过 delete 命令是不能回收表空间的。</span>  </p>
<h3 id="不止是删除数据会造成空洞，插入数据也会。"><a href="#不止是删除数据会造成空洞，插入数据也会。" class="headerlink" title="不止是删除数据会造成空洞，插入数据也会。"></a><span style="color:red;">不止是删除数据会造成空洞，插入数据也会。</span></h3><p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。  </p>
<h2 id="解决：重建表"><a href="#解决：重建表" class="headerlink" title="解决：重建表"></a>解决：重建表</h2><h3 id="alter-table-A-engine-InnoDB"><a href="#alter-table-A-engine-InnoDB" class="headerlink" title="alter table A engine=InnoDB"></a>alter table A engine=InnoDB</h3><p>MySQL 5.6 版本开始引入的 Online DDL，对这个操作流程做了优化。   </p>
<h3 id="重建表的流程：（重建表过程中允许对表做增删改操作）（Online-DDL）"><a href="#重建表的流程：（重建表过程中允许对表做增删改操作）（Online-DDL）" class="headerlink" title="重建表的流程：（重建表过程中允许对表做增删改操作）（Online DDL）"></a>重建表的流程：（重建表过程中允许对表做增删改操作）（Online DDL）</h3><pre><code>1. 建立一个临时文件，扫描表 A 主键的所有数据页；
2. 用数据页中表 A 的记录生成 B+ 树，存储到临时文件（InnoDB内部创建，需要占用临时空间）中；
3. 生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态；
4. 临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对应的就是图中 state3 的状态；
5. 用临时文件替换表 A 的数据文件。   </code></pre><p>alter 语句在启动的时候需要获取 MDL 写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了。  </p>
<h2 id="Online-和-inplace"><a href="#Online-和-inplace" class="headerlink" title="Online 和 inplace"></a>Online 和 inplace</h2><p>alter table t engine=innodb,ALGORITHM=inplace;   </p>
<pre><code>1. DDL 过程如果是 Online 的，就一定是 inplace 的；
2. 反过来未必，也就是说 inplace 的 DDL，有可能不是 Online 的。截止到 MySQL8.0，添加全文索引（FULLTEXT index）和空间索引 (SPATIAL index) 就属于这种情况。  </code></pre><h3 id="optimize-table、analyze-table-和-alter-table-这三种方式的区别"><a href="#optimize-table、analyze-table-和-alter-table-这三种方式的区别" class="headerlink" title="optimize table、analyze table 和 alter table 这三种方式的区别"></a>optimize table、analyze table 和 alter table 这三种方式的区别</h3><ul>
<li>从 MySQL 5.6 版本开始，alter table t engine = InnoDB（也就是 recreate）默认的就是上面图 4 的流程了；</li>
<li>analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了 MDL 读锁；</li>
<li>optimize table t 等于 recreate+analyze。    </li>
</ul>
<h1 id="十二、count-命令速度"><a href="#十二、count-命令速度" class="headerlink" title="十二、count(*)命令速度"></a>十二、count(*)命令速度</h1><p>count(*) 的实现方式  </p>
<ul>
<li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；   </li>
<li>而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。  </li>
</ul>
<p>InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。   </p>
<p>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。  </p>
<ul>
<li>MyISAM 表虽然 count(*) 很快，但是不支持事务；</li>
<li>show table status 命令虽然返回很快，但是不准确；</li>
<li>InnoDB 表直接 count(*) 会遍历全表，虽然结果准确，但会导致性能问题。  </li>
</ul>
<h2 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h2><h3 id="1）用缓存系统保存计数"><a href="#1）用缓存系统保存计数" class="headerlink" title="1）用缓存系统保存计数"></a>1）用缓存系统保存计数</h3><p>将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使 Redis 正常工作，这个值还是逻辑上不精确的。（一致性问题）  </p>
<h3 id="2）在数据库保存计数"><a href="#2）在数据库保存计数" class="headerlink" title="2）在数据库保存计数"></a>2）在数据库保存计数</h3><p>把这个计数直接放到数据库里单独的一张计数表<br>解决了崩溃丢失的问题，InnoDB 是支持崩溃恢复不丢数据的。   </p>
<p>把计数放在 Redis 里面，不能够保证计数和 MySQL 表里的数据精确一致的原因，是这两个不同的存储构成的系统，不支持分布式事务，无法拿到精确一致的视图。而把计数值也放在 MySQL 中，就解决了一致性视图的问题。</p>
<p>按照效率排序的话，count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)  </p>
<h1 id="十三、order-by工作机制"><a href="#十三、order-by工作机制" class="headerlink" title="十三、order by工作机制"></a>十三、order by工作机制</h1><h2 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h2><p>直接把需要展示的字段放到内存中排序后得到结果<br>“按 name 排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 sort_buffer_size。<br>sort_buffer_size，就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。    </p>
<h2 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h2><p>MySQL 认为排序的单行长度太大，会把部分字段放在内存中排序，然后通过主键返回磁盘查询整个字段得到结果。   </p>
<h2 id="全字段排序-VS-rowid-排序"><a href="#全字段排序-VS-rowid-排序" class="headerlink" title="全字段排序 VS rowid 排序"></a>全字段排序 VS rowid 排序</h2><p>如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。  </p>
<p>如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。<br>这也就体现了 MySQL 的一个设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问。   </p>
<p>对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。  </p>
<p>覆盖索引是指，索引上的信息足够满足查询请求，不需要再回到主键索引上去取数据。    </p>
<h1 id="十四、正确显示随机消息"><a href="#十四、正确显示随机消息" class="headerlink" title="十四、正确显示随机消息"></a>十四、正确显示随机消息</h1><h2 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h2><p>order by rand() 使用了内存临时表，内存临时表排序的时候使用了 rowid 排序方法。   </p>
<h2 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h2><p>tmp_table_size 这个配置限制了内存临时表的大小，默认值是 16M。如果临时表大小超过了 tmp_table_size，那么内存临时表就会转成磁盘临时表。磁盘临时表使用的引擎默认是 InnoDB，是由参数 internal_tmp_disk_storage_engine控制的。<br>当使用磁盘临时表的时候，对应的就是一个没有显式索引的 InnoDB 表的排序过程。   </p>
<h2 id="优先队列排序算法"><a href="#优先队列排序算法" class="headerlink" title="优先队列排序算法"></a>优先队列排序算法</h2><p>不使用临时文件的算法—归并排序算法的原因：归并排序会把所有数据排序（不需要）<br>优先队列算法，就可以精确地只得到三个最小值，执行流程如下：  </p>
<pre><code>1. 对于这 10000 个准备排序的 (R,rowid)，先取前三行，构造成一个堆；
2. 取下一个行 (R’,rowid’)，跟当前堆里面最大的 R 比较，如果 R’小于 R，把这个(R,rowid) 从堆中去掉，换成 (R’,rowid’)；
3. 重复第 2 步，直到第 10000 个 (R’,rowid’) 完成比较。    </code></pre><p>总之，不论是使用哪种类型的临时表，order by rand() 这种写法都会让计算过程非常复杂，需要大量的扫描行数，因此排序过程的资源消耗也会很大。  </p>
<h2 id="随机排序算法"><a href="#随机排序算法" class="headerlink" title="随机排序算法"></a>随机排序算法</h2><p>取 max(id) 和 min(id) 都是不需要扫描索引的，而第三步的select 也可以用索引快速定位  </p>
<p>MySQL 处理 limit Y,1 的做法就是按顺序一个一个地读出来，丢掉前 Y 个，然后把下一个记录作为返回结果，因此这一步需要扫描 Y+1 行。  </p>
<h1 id="十五、相同逻辑的不同SQL语句性能差异"><a href="#十五、相同逻辑的不同SQL语句性能差异" class="headerlink" title="十五、相同逻辑的不同SQL语句性能差异"></a>十五、相同逻辑的不同SQL语句性能差异</h1><h2 id="1-条件字段函数操作"><a href="#1-条件字段函数操作" class="headerlink" title="1.条件字段函数操作"></a>1.条件字段函数操作</h2><p>如果对字段做了函数计算，就用不上索引了，这是 MySQL 的规定。   </p>
<p>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。  </p>
<h2 id="2-隐式类型转换"><a href="#2-隐式类型转换" class="headerlink" title="2.隐式类型转换"></a>2.隐式类型转换</h2><ol>
<li>数据类型转换的规则是什么？<br>在 MySQL 中，字符串和数字做比较的话，是将字符串转换成数字。  </li>
<li>为什么有数据类型转换，就需要走全索引扫描？<br>对索引字段做函数操作，优化器会放弃<br>走树搜索功能。  </li>
</ol>
<h2 id="3-隐式字符编码转换"><a href="#3-隐式字符编码转换" class="headerlink" title="3.隐式字符编码转换"></a>3.隐式字符编码转换</h2><p>两表匹配时要注意字符编码问题，字符集不同则不能用关联字段的索引。<br>连接过程中要求在被驱动表的索引字段上加函数操作，是直接导致对被驱动表做全表扫描的原因。  </p>
<h1 id="十六、“查一行”执行速度慢的原因"><a href="#十六、“查一行”执行速度慢的原因" class="headerlink" title="十六、“查一行”执行速度慢的原因"></a>十六、“查一行”执行速度慢的原因</h1><p>了在一个简单的表上，执行“查一行”，可能会出现的被锁住和执行慢的例子。这其中涉及到了表锁、行锁和一致性读的概念。  </p>
<h2 id="查询长时间不返回"><a href="#查询长时间不返回" class="headerlink" title="查询长时间不返回"></a>查询长时间不返回</h2><p>等MDL锁<br>等flush  </p>
<h2 id="查询慢"><a href="#查询慢" class="headerlink" title="查询慢"></a>查询慢</h2><p>当前读和一致性读区别  </p>
<h1 id="十七、幻读问题"><a href="#十七、幻读问题" class="headerlink" title="十七、幻读问题"></a>十七、幻读问题</h1>
    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/study/" rel="tag"># study</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/12/19/mysql-1/" rel="next" title="mysql-1">
                  <i class="fa fa-chevron-left"></i> mysql-1
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2020/01/01/ES reindex/" rel="prev" title="">
                   <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、SQL语句执行-基本架构"><span class="nav-number">1.</span> <span class="nav-text">一、SQL语句执行 基本架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MVCC—-多版本并发控制"><span class="nav-number">1.0.1.</span> <span class="nav-text">MVCC—-多版本并发控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#当前读和一致性读"><span class="nav-number">1.0.2.</span> <span class="nav-text">当前读和一致性读</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、日志"><span class="nav-number">2.</span> <span class="nav-text">二、日志</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#WAL-技术"><span class="nav-number">2.1.</span> <span class="nav-text">WAL 技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redo-log（crash-safe能力）InnoDB特有"><span class="nav-number">2.2.</span> <span class="nav-text">redo log（crash-safe能力）InnoDB特有</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#binlog"><span class="nav-number">2.3.</span> <span class="nav-text">binlog</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#区别："><span class="nav-number">2.4.</span> <span class="nav-text">区别：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#执行update流程："><span class="nav-number">2.5.</span> <span class="nav-text">执行update流程：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#两阶段提交时Mysql异常重启后事务情况："><span class="nav-number">2.6.</span> <span class="nav-text">两阶段提交时Mysql异常重启后事务情况：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#崩溃恢复时的判断规则："><span class="nav-number">2.6.1.</span> <span class="nav-text">崩溃恢复时的判断规则：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binlog-有着-redo-log-无法替代的功能。"><span class="nav-number">2.6.2.</span> <span class="nav-text">binlog 有着 redo log 无法替代的功能。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正常运行中的实例，数据写入后的最终落盘，是从-redo-log-更新过来的还是从-buffer-pool-更新过来的？"><span class="nav-number">2.6.3.</span> <span class="nav-text">正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、事务隔离"><span class="nav-number">3.</span> <span class="nav-text">三、事务隔离</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#可重复读是InnoDB默认的隔离级别"><span class="nav-number">3.1.</span> <span class="nav-text">可重复读是InnoDB默认的隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）"><span class="nav-number">3.1.1.</span> <span class="nav-text">ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#脏读（dirty-read）、不可重复读（non-repeatable-read）、幻读（phantom-read）"><span class="nav-number">3.1.2.</span> <span class="nav-text">脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL标准的事务隔离级别："><span class="nav-number">3.2.</span> <span class="nav-text">SQL标准的事务隔离级别：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql的事务启动方式："><span class="nav-number">3.3.</span> <span class="nav-text">Mysql的事务启动方式：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、索引"><span class="nav-number">4.</span> <span class="nav-text">四、索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常见模型：哈希表、有序数组和搜索树。"><span class="nav-number">4.1.</span> <span class="nav-text">常见模型：哈希表、有序数组和搜索树。</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB使用B-树模型，减少单次查询的磁盘访问次数。"><span class="nav-number">4.1.1.</span> <span class="nav-text">InnoDB使用B+树模型，减少单次查询的磁盘访问次数。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引维护："><span class="nav-number">4.1.2.</span> <span class="nav-text">索引维护：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#联合索引：安排索引内的字段顺序"><span class="nav-number">4.1.3.</span> <span class="nav-text">联合索引：安排索引内的字段顺序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五、全局锁、表锁、行锁"><span class="nav-number">5.</span> <span class="nav-text">五、全局锁、表锁、行锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、全局锁"><span class="nav-number">5.1.</span> <span class="nav-text">1、全局锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、表级锁"><span class="nav-number">5.2.</span> <span class="nav-text">2、表级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）表锁"><span class="nav-number">5.2.1.</span> <span class="nav-text">1）表锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）元数据锁"><span class="nav-number">5.2.2.</span> <span class="nav-text">2）元数据锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、行锁"><span class="nav-number">5.3.</span> <span class="nav-text">3、行锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引擎层由各个引擎自己实现，不是所有引擎都支持。InnoDB支持。"><span class="nav-number">5.3.1.</span> <span class="nav-text">引擎层由各个引擎自己实现，不是所有引擎都支持。InnoDB支持。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁：事务A等待事务B释放行锁，事务B等待事务A释放行锁。"><span class="nav-number">5.3.2.</span> <span class="nav-text">死锁：事务A等待事务B释放行锁，事务B等待事务A释放行锁。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决策略："><span class="nav-number">5.3.3.</span> <span class="nav-text">解决策略：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#但死锁检测存在问题：并发量大导致CPU资源耗费。"><span class="nav-number">5.3.4.</span> <span class="nav-text">但死锁检测存在问题：并发量大导致CPU资源耗费。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决由这种热点行更新导致的性能问题："><span class="nav-number">5.3.5.</span> <span class="nav-text">解决由这种热点行更新导致的性能问题：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#六、事务隔离"><span class="nav-number">6.</span> <span class="nav-text">六、事务隔离</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#七、普通索引和唯一索引"><span class="nav-number">7.</span> <span class="nav-text">七、普通索引和唯一索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-change-buffer："><span class="nav-number">7.0.1.</span> <span class="nav-text">1.change buffer：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-merge："><span class="nav-number">7.0.2.</span> <span class="nav-text">2.merge：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-change-buffer-的使用场景"><span class="nav-number">7.0.3.</span> <span class="nav-text">3.change buffer 的使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-change-buffer-和-redo-log"><span class="nav-number">7.0.4.</span> <span class="nav-text">4.change buffer 和 redo log</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#八、MySQL选择索引"><span class="nav-number">8.</span> <span class="nav-text">八、MySQL选择索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#索引选择异常和处理"><span class="nav-number">8.1.</span> <span class="nav-text">索引选择异常和处理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#九、字符串字段加索引"><span class="nav-number">9.</span> <span class="nav-text">九、字符串字段加索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-前缀索引"><span class="nav-number">9.1.</span> <span class="nav-text">1.前缀索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-前缀索引对覆盖索引的影响"><span class="nav-number">9.2.</span> <span class="nav-text">2.前缀索引对覆盖索引的影响</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-倒序存储和Hash字段索引："><span class="nav-number">9.3.</span> <span class="nav-text">3.倒序存储和Hash字段索引：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#相同点："><span class="nav-number">9.3.1.</span> <span class="nav-text">相同点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#区别：-1"><span class="nav-number">9.3.2.</span> <span class="nav-text">区别：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十、SQL语句偶尔变慢的原因"><span class="nav-number">10.</span> <span class="nav-text">十、SQL语句偶尔变慢的原因</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB-刷脏页的控制策略"><span class="nav-number">10.1.</span> <span class="nav-text">InnoDB 刷脏页的控制策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计策略控制刷脏页的速度，会参考因素："><span class="nav-number">10.2.</span> <span class="nav-text">设计策略控制刷脏页的速度，会参考因素：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#找“邻居”"><span class="nav-number">10.2.1.</span> <span class="nav-text">找“邻居”</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十一、数据库表的空间回收"><span class="nav-number">11.</span> <span class="nav-text">十一、数据库表的空间回收</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据删除流程"><span class="nav-number">11.1.</span> <span class="nav-text">数据删除流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不止是删除数据会造成空洞，插入数据也会。"><span class="nav-number">11.1.1.</span> <span class="nav-text">不止是删除数据会造成空洞，插入数据也会。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解决：重建表"><span class="nav-number">11.2.</span> <span class="nav-text">解决：重建表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#alter-table-A-engine-InnoDB"><span class="nav-number">11.2.1.</span> <span class="nav-text">alter table A engine=InnoDB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重建表的流程：（重建表过程中允许对表做增删改操作）（Online-DDL）"><span class="nav-number">11.2.2.</span> <span class="nav-text">重建表的流程：（重建表过程中允许对表做增删改操作）（Online DDL）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Online-和-inplace"><span class="nav-number">11.3.</span> <span class="nav-text">Online 和 inplace</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#optimize-table、analyze-table-和-alter-table-这三种方式的区别"><span class="nav-number">11.3.1.</span> <span class="nav-text">optimize table、analyze table 和 alter table 这三种方式的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十二、count-命令速度"><span class="nav-number">12.</span> <span class="nav-text">十二、count(*)命令速度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解决："><span class="nav-number">12.1.</span> <span class="nav-text">解决：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）用缓存系统保存计数"><span class="nav-number">12.1.1.</span> <span class="nav-text">1）用缓存系统保存计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）在数据库保存计数"><span class="nav-number">12.1.2.</span> <span class="nav-text">2）在数据库保存计数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十三、order-by工作机制"><span class="nav-number">13.</span> <span class="nav-text">十三、order by工作机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#全字段排序"><span class="nav-number">13.1.</span> <span class="nav-text">全字段排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rowid排序"><span class="nav-number">13.2.</span> <span class="nav-text">rowid排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全字段排序-VS-rowid-排序"><span class="nav-number">13.3.</span> <span class="nav-text">全字段排序 VS rowid 排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十四、正确显示随机消息"><span class="nav-number">14.</span> <span class="nav-text">十四、正确显示随机消息</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内存临时表"><span class="nav-number">14.1.</span> <span class="nav-text">内存临时表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#磁盘临时表"><span class="nav-number">14.2.</span> <span class="nav-text">磁盘临时表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优先队列排序算法"><span class="nav-number">14.3.</span> <span class="nav-text">优先队列排序算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#随机排序算法"><span class="nav-number">14.4.</span> <span class="nav-text">随机排序算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十五、相同逻辑的不同SQL语句性能差异"><span class="nav-number">15.</span> <span class="nav-text">十五、相同逻辑的不同SQL语句性能差异</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-条件字段函数操作"><span class="nav-number">15.1.</span> <span class="nav-text">1.条件字段函数操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-隐式类型转换"><span class="nav-number">15.2.</span> <span class="nav-text">2.隐式类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-隐式字符编码转换"><span class="nav-number">15.3.</span> <span class="nav-text">3.隐式字符编码转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十六、“查一行”执行速度慢的原因"><span class="nav-number">16.</span> <span class="nav-text">十六、“查一行”执行速度慢的原因</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#查询长时间不返回"><span class="nav-number">16.1.</span> <span class="nav-text">查询长时间不返回</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查询慢"><span class="nav-number">16.2.</span> <span class="nav-text">查询慢</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十七、幻读问题"><span class="nav-number">17.</span> <span class="nav-text">十七、幻读问题</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lynn</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lynn</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.1
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/pisces.js?v=7.4.1"></script>

<script src="/js/next-boot.js?v=7.4.1"></script>



  








  <script src="/js/local-search.js?v=7.4.1"></script>














  

  

  

</body>
</html>
